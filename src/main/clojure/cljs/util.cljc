;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns cljs.util
  (:require [clojure.java.io :as io]
            [clojure.string :as string]
            [clojure.set :as set]
            [clojure.edn :as edn])
  (:import [java.io File]
           [java.net URL]))

;; next line is auto-generated by the build-script - Do not edit!
(def ^:dynamic *clojurescript-version*)

(defn ^String clojurescript-version
  "Returns clojurescript version as a printable string."
  []
  (if (bound? #'*clojurescript-version*)
    (str
     (:major *clojurescript-version*)
     "."
     (:minor *clojurescript-version*)
     (when-let [i (:incremental *clojurescript-version*)]
       (str "." i))
     (when-let [q (:qualifier *clojurescript-version*)]
       (str "." q))
     (when (:interim *clojurescript-version*)
       "-SNAPSHOT"))
    "0.0.0000"))

(defn ^String compiled-by-version [f]
  (with-open [reader (io/reader f)]
    (let [match (->> reader line-seq first
                     (re-matches #".*ClojureScript (\d+\.\d+\.\d+).*$"))]
      (or (and match (second match)) "0.0.0000"))))

(defn build-options [^File f]
  (with-open [reader (io/reader f)]
    (let [match (->> reader line-seq first
                  (re-matches #".*ClojureScript \d+\.\d+\.\d+ (.*)$"))]
          (and match (edn/read-string (second match))))))

(defn munge-path [ss]
  (clojure.lang.Compiler/munge (str ss)))

(defn ns->relpath
  "Given a namespace as a symbol return the relative path. May optionally
  provide the file extension, defaults to :cljs."
  ([ns] (ns->relpath ns :cljs))
  ([ns ext]
   (str (string/replace (munge-path ns) \. \/) "." (name ext))))

(defn ns->source
  "Given a namespace as a symbol return the corresponding resource if it exists."
  [ns]
  (or (io/resource (ns->relpath ns :cljs))
      (io/resource (ns->relpath ns :cljc))))

(defn path-seq
  [file-str]
  (->> File/separator
       java.util.regex.Pattern/quote
       re-pattern
       (string/split file-str)))

(defn to-path
  ([parts]
     (to-path parts File/separator))
  ([parts sep]
    (apply str (interpose sep parts))))

(declare ext)

(defn ^File to-target-file
  ([target-dir ns-info]
    (to-target-file target-dir ns-info "js"))
  ([target-dir {:keys [ns source-file] :as ns-info} ext]
    (let [src-ext (if source-file
                    (cljs.util/ext source-file)
                    "cljs")
          ns      (if (or (= src-ext "clj")
                          (and (= ns 'cljs.core) (= src-ext "cljc")))
                    (symbol (str ns "$macros"))
                    ns)
          relpath (string/split (munge-path (str ns)) #"\.")
          parents (cond-> (butlast relpath)
                    target-dir (conj target-dir))]
      (cond->> (io/file (str (last relpath) (str "." ext)))
        (seq parents)
        (io/file (to-path parents))))))

(defn mkdirs
  "Create all parent directories for the passed file."
  [^File f]
  (.mkdirs (.getParentFile (.getCanonicalFile f))))

(defn output-directory
  ([opts] (output-directory opts "out"))
  ([opts default]
   {:pre [(or (nil? opts) (map? opts))]}
   (or (:output-dir opts) default)))

(defn file? [f]
  (instance? File f))

(defn url? [f]
  (instance? URL f))

(defn ^String filename [^File f]
  (.getName f))

(defn ^String path [x]
  {:pre [(or (file? x) (url? x) (string? x))]}
  (cond
    (file? x) (.getAbsolutePath ^File x)
    (url? x) (.getPath ^URL x)
    (string? x) x))

(defn ^String ext
  "Given a file, url or string return the file extension."
  [x]
  {:pre [(or (file? x) (url? x) (string? x))]}
  (let [s (cond
            (file? x) (filename x)
            (url? x) (path x)
            (string? x) x)]
    (last (string/split s #"\."))))

(defn ^String get-name
  "Given a file or url return the last component of the path."
  [x]
  {:pre [(or (file? x) (url? x))]}
  (if (file? x)
    (filename x)
    (last (string/split (path x) #"\/"))))

(defn last-modified [src]
  (cond
    (file? src) (.lastModified ^File src)
    (url? src) (.getLastModified (.openConnection ^URL src))
    :else
    (throw
      (IllegalArgumentException. (str "Cannot get last modified for " src)))))

(defn file-or-resource [s]
  (or (and (.exists (io/file s)) (io/file s))
      (io/resource s)))

(defn topo-sort
  ([x get-deps]
    (topo-sort x 0 (atom (sorted-map)) (memoize get-deps)))
  ([x depth state memo-get-deps]
    (let [deps (memo-get-deps x)]
      (swap! state update-in [depth] (fnil into #{}) deps)
      (doseq [dep deps]
        (topo-sort dep (inc depth) state memo-get-deps))
      (doseq [[<depth _] (subseq @state < depth)]
        (swap! state update-in [<depth] set/difference deps))
      (when (= depth 0)
        (distinct (apply concat (vals @state)))))))

(defn valid-js-id-start? [s]
  (re-find #"(?U)^[\p{Alpha}_$]" s))

(defn debug-prn
  [& args]
  (binding [*out* *err*]
    (apply println args)))

(defmacro measure
  "Like cljs.core/time but toggleable and takes a message string."
  {:added "1.0"}
  ([msg expr] `(measure true ~msg ~expr))
  ([enable msg expr]
    `(if ~enable
       (let [start# (. System (nanoTime))
             ret# ~expr]
         (debug-prn (str ~msg ", elapsed time:") (/ (double (- (. System (nanoTime)) start#)) 1000000.0) "msecs")
         ret#)
       ~expr)))

(defmacro compile-if
  ([exp then] `(compile-if ~exp ~then nil))
  ([exp then else]
   (if (try (eval exp)
            (catch Throwable _ false))
     `(do ~then)
     `(do ~else))))
